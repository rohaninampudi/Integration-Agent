{
  "timestamp": "2026-01-14T18:45:13.876680",
  "git_sha": "34e84af",
  "prompt_hash": "8ff81bc6",
  "total_scenarios": 12,
  "metrics": {
    "action_accuracy": 100.0,
    "liquid_valid": 100.0,
    "renders_to_json": 100.0,
    "avg_latency_ms": 64225.74890466666,
    "error_rate": 0.0
  },
  "details": [
    {
      "scenario_id": 0,
      "request": "Post the summary to Slack",
      "expected_action": "slack_post_message",
      "actual_action": "slack_post_message",
      "action_correct": true,
      "liquid_valid": true,
      "renders_to_json": true,
      "reasoning": "The user asked to post the summary to Slack. The 'slack_post_message' action is appropriate for sending messages to a Slack channel. The provided variables include 'slack_channel' for the destination and 'summary' for the message content, which map directly to the 'channel' and 'text' fields required by chat.postMessage.",
      "proposed_config": "{ \"channel\": \"{{ slack_channel }}\", \"text\": \"{{ summary }}\" }",
      "rendered_config": "{ \"channel\": \"#product-alerts\", \"text\": \"Found 3 products. Average price: $91.66. Lowest: USB-C Hub ($45.00)\" }",
      "latency_ms": 27176.049688000006,
      "error": null
    },
    {
      "scenario_id": 1,
      "request": "Add these products to my Notion database",
      "expected_action": "notion_create_page",
      "actual_action": "notion_create_page",
      "action_correct": true,
      "liquid_valid": true,
      "renders_to_json": true,
      "reasoning": "To add items to a Notion database, each product should be created as a separate page. The 'notion_create_page' action is appropriate because it creates pages within a specified database. Using the Notion API structure from the docs, we map each product's name to the database Title property ('Name'), price to a Number property ('Price'), and URL to a URL property ('URL'). We use a Liquid loop to generate one page payload per product, referencing the provided notion_database_id.",
      "proposed_config": "[{% for product in scraper_results %}{ \"parent\": { \"database_id\": \"{{ notion_database_id }}\" }, \"properties\": { \"Name\": { \"title\": [ { \"text\": { \"content\": \"{{ product.name }}\" } } ] }, \"Price\": { \"number\": {{ product.price }} }, \"URL\": { \"url\": \"{{ product.url }}\" } } }{% unless forloop.last %}, {% endunless %}{% endfor %}]",
      "rendered_config": "[{ \"parent\": { \"database_id\": \"8a3b1c4d-5e6f-7a8b-9c0d-1e2f3a4b5c6d\" }, \"properties\": { \"Name\": { \"title\": [ { \"text\": { \"content\": \"Wireless Headphones\" } } ] }, \"Price\": { \"number\": 79.99 }, \"URL\": { \"url\": \"https://store.example.com/p/1001\" } } }, { \"parent\": { \"database_id\": \"8a3b1c4d-5e6f-7a8b-9c0d-1e2f3a4b5c6d\" }, \"properties\": { \"Name\": { \"title\": [ { \"text\": { \"content\": \"USB-C Hub\" } } ] }, \"Price\": { \"number\": 45.0 }, \"URL\": { \"url\": \"https://store.example.com/p/1002\" } } }, { \"parent\": { \"database_id\": \"8a3b1c4d-5e6f-7a8b-9c0d-1e2f3a4b5c6d\" }, \"properties\": { \"Name\": { \"title\": [ { \"text\": { \"content\": \"Mechanical Keyboard\" } } ] }, \"Price\": { \"number\": 149.99 }, \"URL\": { \"url\": \"https://store.example.com/p/1003\" } } }]",
      "latency_ms": 113375.926113,
      "error": null
    },
    {
      "scenario_id": 2,
      "request": "Create a GitHub issue for the failed scrape",
      "expected_action": "github_create_issue",
      "actual_action": "github_create_issue",
      "action_correct": true,
      "liquid_valid": true,
      "renders_to_json": true,
      "reasoning": "The user wants to track a failed scrape in GitHub. The 'github_create_issue' action is purpose-built for creating issues. According to the API docs, 'title' is required and 'body' and 'labels' are optional. I used the provided variables: 'summary' for a concise report in the body and 'error_details' in a fenced code block for readability. Labels mark it as an automated bug related to scraping.",
      "proposed_config": "{ \"title\": \"Scrape Failed - Automated Report\", \"body\": \"## Summary\\n\\n{{ summary }}\\n\\n## Error Details\\n\\n```\\n{{ error_details }}\\n```\\n\\n---\\n*This issue was automatically created by the Integration Agent.*\", \"labels\": [\"bug\", \"scrape\", \"automated\"] }",
      "rendered_config": "{ \"title\": \"Scrape Failed - Automated Report\", \"body\": \"## Summary\\n\\nScrape failed: Connection timeout after 30s. URL: https://store.example.com\\n\\n## Error Details\\n\\n```\\nTimeoutError: Request exceeded 30000ms\\n```\\n\\n---\\n*This issue was automatically created by the Integration Agent.*\", \"labels\": [\"bug\", \"scrape\", \"automated\"] }",
      "latency_ms": 61134.82098100002,
      "error": null
    },
    {
      "scenario_id": 3,
      "request": "Add these results to the existing spreadsheet",
      "expected_action": "google_sheets_append",
      "actual_action": "google_sheets_append",
      "action_correct": true,
      "liquid_valid": true,
      "renders_to_json": true,
      "reasoning": "The user wants to add rows to an existing spreadsheet, and a spreadsheet_id is provided. The 'google_sheets_append' action is appropriate because it appends rows to an existing Google Sheet. The config uses the provided spreadsheet_id, appends to Sheet1 columns A-C, and loops through scraper_results to build the 2D values array. The payload aligns with the spreadsheets.values.append API structure retrieved.",
      "proposed_config": "{ \"spreadsheetId\": \"{{ spreadsheet_id }}\", \"range\": \"Sheet1!A:C\", \"valueInputOption\": \"USER_ENTERED\", \"values\": [{% for product in scraper_results %}[\"{{ product.name }}\", {{ product.price }}, \"{{ product.url }}\"]{% unless forloop.last %}, {% endunless %}{% endfor %}] }",
      "rendered_config": "{ \"spreadsheetId\": \"1BxiMVs0XRA5nFMdKvBdBZjgmUUqptlbs74OgvE2upms\", \"range\": \"Sheet1!A:C\", \"valueInputOption\": \"USER_ENTERED\", \"values\": [[\"Wireless Headphones\", 79.99, \"https://store.example.com/p/1001\"], [\"USB-C Hub\", 45.0, \"https://store.example.com/p/1002\"]] }",
      "latency_ms": 57908.15678400003,
      "error": null
    },
    {
      "scenario_id": 4,
      "request": "Update the Notion block with the new status message",
      "expected_action": "notion_update_block",
      "actual_action": "notion_update_block",
      "action_correct": true,
      "liquid_valid": true,
      "renders_to_json": true,
      "reasoning": "The user wants to update an existing Notion block\u2019s content. The 'notion_update_block' action is specifically for updating block content. We have the required variables: block_id to target the block and new_content for the updated text. The retrieved documentation shows Notion blocks (e.g., paragraph) are updated using a type-specific property with a rich_text array; therefore, we set the paragraph.rich_text to the new status message.",
      "proposed_config": "{ \"block_id\": \"{{ block_id }}\", \"paragraph\": { \"rich_text\": [ { \"type\": \"text\", \"text\": { \"content\": \"{{ new_content }}\" } } ] } }",
      "rendered_config": "{ \"block_id\": \"b1c2d3e4-5f6a-7b8c-9d0e-1f2a3b4c5d6e\", \"paragraph\": { \"rich_text\": [ { \"type\": \"text\", \"text\": { \"content\": \"Status: Completed \u2705 - All tasks finished successfully.\" } } ] } }",
      "latency_ms": 58405.48963700001,
      "error": null
    },
    {
      "scenario_id": 5,
      "request": "Create a record in my Airtable base with the product data",
      "expected_action": "airtable_create_record",
      "actual_action": "airtable_create_record",
      "action_correct": true,
      "liquid_valid": true,
      "renders_to_json": true,
      "reasoning": "The user wants to create a new record in an Airtable base using provided product data. After reviewing available actions, 'airtable_create_record' is the correct choice. The Airtable API requires baseId, tableIdOrName, and a records array containing a fields object. Using the retrieved API docs, the config includes baseId and tableIdOrName from the workflow variables and maps product_data properties into the fields object with correct JSON types.",
      "proposed_config": "{ \"baseId\": \"{{ base_id }}\", \"tableIdOrName\": \"{{ table_name }}\", \"records\": [ { \"fields\": { \"name\": \"{{ product_data.name }}\", \"price\": {{ product_data.price }}, \"category\": \"{{ product_data.category }}\", \"in_stock\": {{ product_data.in_stock }} } } ] }",
      "rendered_config": "{ \"baseId\": \"appXYZ123456789\", \"tableIdOrName\": \"Products\", \"records\": [ { \"fields\": { \"name\": \"New Product\", \"price\": 99.99, \"category\": \"Electronics\", \"in_stock\": true } } ] }",
      "latency_ms": 71215.10747299998,
      "error": null
    },
    {
      "scenario_id": 6,
      "request": "Add this lead as a contact in HubSpot",
      "expected_action": "hubspot_create_contact",
      "actual_action": "hubspot_create_contact",
      "action_correct": true,
      "liquid_valid": true,
      "renders_to_json": true,
      "reasoning": "The user wants to add a lead as a contact in HubSpot. The 'hubspot_create_contact' action is the correct choice for creating contacts. Using the API docs, the payload must include a 'properties' object with at least 'email'. I mapped the provided lead fields to HubSpot's standard properties (email, firstname, lastname, phone, company, jobtitle) and set 'lifecyclestage' to 'lead' to reflect the user's intent.",
      "proposed_config": "{ \"properties\": { \"email\": \"{{ lead.email }}\", \"firstname\": \"{{ lead.first_name }}\", \"lastname\": \"{{ lead.last_name }}\", \"phone\": \"{{ lead.phone }}\", \"company\": \"{{ lead.company }}\", \"jobtitle\": \"{{ lead.job_title }}\", \"lifecyclestage\": \"lead\" } }",
      "rendered_config": "{ \"properties\": { \"email\": \"john.smith@acmecorp.com\", \"firstname\": \"John\", \"lastname\": \"Smith\", \"phone\": \"+1-555-123-4567\", \"company\": \"Acme Corporation\", \"jobtitle\": \"VP of Engineering\", \"lifecyclestage\": \"lead\" } }",
      "latency_ms": 65135.38043099993,
      "error": null
    },
    {
      "scenario_id": 7,
      "request": "Create a Trello card for this task",
      "expected_action": "trello_create_card",
      "actual_action": "trello_create_card",
      "action_correct": true,
      "liquid_valid": true,
      "renders_to_json": true,
      "reasoning": "The user wants to create a Trello card. The available action 'trello_create_card' matches this need. The provided workflow variables include the target list_id and task details (name, description, due_date), which map directly to Trello's required and optional fields: idList, name, desc, and due.",
      "proposed_config": "{ \"idList\": \"{{ list_id }}\", \"name\": \"{{ task.name }}\", \"desc\": \"{{ task.description }}\", \"due\": \"{{ task.due_date }}\" }",
      "rendered_config": "{ \"idList\": \"5f1a2b3c4d5e6f7a8b9c0d1e\", \"name\": \"Review pull request #42\", \"desc\": \"Code review needed for the authentication module updates\", \"due\": \"2024-01-15T17:00:00Z\" }",
      "latency_ms": 35049.74892100006,
      "error": null
    },
    {
      "scenario_id": 8,
      "request": "Create a Jira ticket for this bug",
      "expected_action": "jira_create_issue",
      "actual_action": "jira_create_issue",
      "action_correct": true,
      "liquid_valid": true,
      "renders_to_json": true,
      "reasoning": "The user asked to create a Jira ticket. The available actions include 'jira_create_issue', which matches the request. Based on the Jira API docs, the payload must include fields.project.key, fields.summary, and fields.issuetype.name. I mapped project_key, bug.summary, and set issuetype to 'Bug'. I included bug.description formatted as an ADF document, added bug.priority to fields.priority.name, and looped over labels to populate fields.labels.",
      "proposed_config": "{ \"fields\": { \"project\": { \"key\": \"{{ project_key }}\" }, \"summary\": \"{{ bug.summary }}\", \"issuetype\": { \"name\": \"Bug\" }, \"description\": { \"type\": \"doc\", \"version\": 1, \"content\": [ { \"type\": \"paragraph\", \"content\": [ { \"type\": \"text\", \"text\": \"{{ bug.description }}\" } ] } ] }, \"priority\": { \"name\": \"{{ bug.priority }}\" }, \"labels\": [{% for label in labels %}\"{{ label }}\"{% unless forloop.last %}, {% endunless %}{% endfor %}] } }",
      "rendered_config": "{ \"fields\": { \"project\": { \"key\": \"PROJ\" }, \"summary\": \"Login page returns 500 error on mobile\", \"issuetype\": { \"name\": \"Bug\" }, \"description\": { \"type\": \"doc\", \"version\": 1, \"content\": [ { \"type\": \"paragraph\", \"content\": [ { \"type\": \"text\", \"text\": \"Users on iOS Safari cannot log in. Error occurs after entering credentials.\" } ] } ] }, \"priority\": { \"name\": \"High\" }, \"labels\": [\"mobile\", \"urgent\", \"login\"] } }",
      "latency_ms": 62048.11056599999,
      "error": null
    },
    {
      "scenario_id": 9,
      "request": "Create a new customer in Stripe for this signup",
      "expected_action": "stripe_create_customer",
      "actual_action": "stripe_create_customer",
      "action_correct": true,
      "liquid_valid": true,
      "renders_to_json": true,
      "reasoning": "The user wants to create a new customer in Stripe. The 'stripe_create_customer' action directly corresponds to this task. Using the API docs, we map available workflow variables to Stripe's customer fields: email, name, phone, and include plan and signup_source as metadata for downstream reporting. A descriptive 'description' field is added for traceability of the signup source and plan.",
      "proposed_config": "{ \"email\": \"{{ customer.email }}\", \"name\": \"{{ customer.name }}\", \"phone\": \"{{ customer.phone }}\", \"description\": \"Signup via {{ signup_source }} - Plan: {{ plan }}\", \"metadata\": { \"plan\": \"{{ plan }}\", \"signup_source\": \"{{ signup_source }}\", \"user_name\": \"{{ customer.name }}\", \"user_email\": \"{{ customer.email }}\" } }",
      "rendered_config": "{ \"email\": \"newuser@example.com\", \"name\": \"Jane Doe\", \"phone\": \"+1-555-987-6543\", \"description\": \"Signup via landing_page - Plan: premium\", \"metadata\": { \"plan\": \"premium\", \"signup_source\": \"landing_page\", \"user_name\": \"Jane Doe\", \"user_email\": \"newuser@example.com\" } }",
      "latency_ms": 57187.10286700002,
      "error": null
    },
    {
      "scenario_id": 10,
      "request": "Send an email notification via SendGrid about the order",
      "expected_action": "sendgrid_send_email",
      "actual_action": "sendgrid_send_email",
      "action_correct": true,
      "liquid_valid": true,
      "renders_to_json": true,
      "reasoning": "The user explicitly asked to send an email via SendGrid. The 'sendgrid_send_email' action matches this request and, per the API docs, requires personalizations (recipient), from, subject, and content. The available variables (recipient, from_email, from_name, order) provide all necessary fields. The config uses both text/plain and text/html content, incorporating order details into the subject and body.",
      "proposed_config": "{ \"personalizations\": [ { \"to\": [ { \"email\": \"{{ recipient.email }}\", \"name\": \"{{ recipient.name }}\" } ] } ], \"from\": { \"email\": \"{{ from_email }}\", \"name\": \"{{ from_name }}\" }, \"subject\": \"Your order {{ order.id }} is {{ order.status }}\", \"content\": [ { \"type\": \"text/plain\", \"value\": \"Hi {{ recipient.name }},\\n\\nGood news! Your order {{ order.id }} is {{ order.status }}.\\n\\nOrder total: {{ order.total }}.\\nWe'll send another update if anything changes.\\n\\nThanks,\\n{{ from_name }}\" }, { \"type\": \"text/html\", \"value\": \"<html><body><p>Hi {{ recipient.name }},</p><p>Good news! Your order <strong>{{ order.id }}</strong> is <strong>{{ order.status }}</strong>.</p><p><strong>Order total:</strong> {{ order.total }}</p><p>We&#39;ll send another update if anything changes.</p><p>Thanks,<br>{{ from_name }}</p></body></html>\" } ] }",
      "rendered_config": "{ \"personalizations\": [ { \"to\": [ { \"email\": \"customer@example.com\", \"name\": \"John Customer\" } ] } ], \"from\": { \"email\": \"orders@store.com\", \"name\": \"Store Notifications\" }, \"subject\": \"Your order ORD-12345 is shipped\", \"content\": [ { \"type\": \"text/plain\", \"value\": \"Hi John Customer,\\n\\nGood news! Your order ORD-12345 is shipped.\\n\\nOrder total: $149.99.\\nWe'll send another update if anything changes.\\n\\nThanks,\\nStore Notifications\" }, { \"type\": \"text/html\", \"value\": \"<html><body><p>Hi John Customer,</p><p>Good news! Your order <strong>ORD-12345</strong> is <strong>shipped</strong>.</p><p><strong>Order total:</strong> $149.99</p><p>We&#39;ll send another update if anything changes.</p><p>Thanks,<br>Store Notifications</p></body></html>\" } ] }",
      "latency_ms": 84292.79622799993,
      "error": null
    },
    {
      "scenario_id": 11,
      "request": "Send an SMS alert via Twilio about the system status",
      "expected_action": "twilio_send_sms",
      "actual_action": "twilio_send_sms",
      "action_correct": true,
      "liquid_valid": true,
      "renders_to_json": true,
      "reasoning": "The user wants to send an SMS via Twilio. The 'twilio_send_sms' action is specifically for creating an SMS message using Twilio's API. The config maps the workflow variables to Twilio's required fields: To (alert_phone), From (twilio_number), and Body (constructed from the alert object).",
      "proposed_config": "{ \"To\": \"{{ alert_phone }}\", \"From\": \"{{ twilio_number }}\", \"Body\": \"\ud83d\udea8 System Alert ({{ alert.type | upcase }}): {{ alert.message }}\\nTimestamp: {{ alert.timestamp }}\" }",
      "rendered_config": "{ \"To\": \"+14155551234\", \"From\": \"+14155559876\", \"Body\": \"\ud83d\udea8 System Alert (WARNING): CPU usage exceeded 90% on production server\\nTimestamp: 2024-01-08T14:30:00Z\" }",
      "latency_ms": 77780.29716699995,
      "error": null
    }
  ]
}