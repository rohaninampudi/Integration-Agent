{
  "timestamp": "2026-01-08T13:09:43.013368",
  "git_sha": "8ca89ce",
  "prompt_hash": "b9c21e3f",
  "total_scenarios": 12,
  "metrics": {
    "action_accuracy": 100.0,
    "liquid_valid": 100.0,
    "renders_to_json": 91.66666666666666,
    "avg_latency_ms": 38078.561576257925,
    "error_rate": 0.0
  },
  "details": [
    {
      "scenario_id": 0,
      "request": "Post the summary to Slack",
      "expected_action": "slack_post_message",
      "actual_action": "slack_post_message",
      "action_correct": true,
      "liquid_valid": true,
      "renders_to_json": true,
      "reasoning": "The user wants to post a message to Slack. The 'slack_post_message' action (Slack Web API chat.postMessage) is appropriate. According to the API docs, 'channel' and 'text' are required. We use the provided workflow variables 'slack_channel' for the channel and 'summary' for the message text.",
      "proposed_config": "{ \"channel\": \"{{ slack_channel }}\", \"text\": \"{{ summary }}\" }",
      "rendered_config": "{ \"channel\": \"#product-alerts\", \"text\": \"Found 3 products. Average price: $91.66. Lowest: USB-C Hub ($45.00)\" }",
      "latency_ms": 18204.16716602631,
      "error": null
    },
    {
      "scenario_id": 1,
      "request": "Add these products to my Notion database",
      "expected_action": "notion_create_page",
      "actual_action": "notion_create_page",
      "action_correct": true,
      "liquid_valid": true,
      "renders_to_json": true,
      "reasoning": "The user wants to add multiple products as entries in a Notion database. The 'notion_create_page' action is appropriate because each product should be created as a page in the specified database. Based on the Notion Create Page API, each page requires a parent database_id and a properties object. The proposed config uses a Liquid loop over scraper_results to generate one page payload per product, mapping fields to common Notion property types: Name (title), Price (number), and URL (url). Ensure your Notion database has properties named 'Name', 'Price', and 'URL' or adjust the property names in the template accordingly.",
      "proposed_config": "[{% for product in scraper_results %}{ \"parent\": { \"database_id\": \"{{ notion_database_id }}\" }, \"properties\": { \"Name\": { \"title\": [{ \"text\": { \"content\": \"{{ product.name }}\" } }] }, \"Price\": { \"number\": {{ product.price }} }, \"URL\": { \"url\": \"{{ product.url }}\" } } }{% unless forloop.last %}, {% endunless %}{% endfor %}]",
      "rendered_config": "[{ \"parent\": { \"database_id\": \"8a3b1c4d-5e6f-7a8b-9c0d-1e2f3a4b5c6d\" }, \"properties\": { \"Name\": { \"title\": [{ \"text\": { \"content\": \"Wireless Headphones\" } }] }, \"Price\": { \"number\": 79.99 }, \"URL\": { \"url\": \"https://store.example.com/p/1001\" } } }, { \"parent\": { \"database_id\": \"8a3b1c4d-5e6f-7a8b-9c0d-1e2f3a4b5c6d\" }, \"properties\": { \"Name\": { \"title\": [{ \"text\": { \"content\": \"USB-C Hub\" } }] }, \"Price\": { \"number\": 45.0 }, \"URL\": { \"url\": \"https://store.example.com/p/1002\" } } }, { \"parent\": { \"database_id\": \"8a3b1c4d-5e6f-7a8b-9c0d-1e2f3a4b5c6d\" }, \"properties\": { \"Name\": { \"title\": [{ \"text\": { \"content\": \"Mechanical Keyboard\" } }] }, \"Price\": { \"number\": 149.99 }, \"URL\": { \"url\": \"https://store.example.com/p/1003\" } } }]",
      "latency_ms": 123200.43370802887,
      "error": null
    },
    {
      "scenario_id": 2,
      "request": "Create a GitHub issue for the failed scrape",
      "expected_action": "github_create_issue",
      "actual_action": "github_create_issue",
      "action_correct": true,
      "liquid_valid": true,
      "renders_to_json": false,
      "reasoning": "The user wants to create a GitHub issue to track a failed scrape. The 'github_create_issue' action is designed for creating issues in a repository. According to the API docs, the payload must include a 'title' and can optionally include a 'body' and 'labels'. I used the provided 'summary' and 'error_details' variables to construct a clear issue body with Markdown formatting and added relevant labels.",
      "proposed_config": "{ \\",
      "rendered_config": "{ \\",
      "latency_ms": 29715.040958020836,
      "error": null
    },
    {
      "scenario_id": 3,
      "request": "Add these results to the existing spreadsheet",
      "expected_action": "google_sheets_append",
      "actual_action": "google_sheets_append",
      "action_correct": true,
      "liquid_valid": true,
      "renders_to_json": true,
      "reasoning": "The user wants to add rows to an existing spreadsheet and a spreadsheet_id is available. The 'google_sheets_append' action matches this need. The API docs indicate the minimal payload requires spreadsheetId, range, valueInputOption, and a 2D 'values' array. We loop over scraper_results to build the rows and avoid trailing commas using forloop.last.",
      "proposed_config": "{ \"spreadsheetId\": \"{{ spreadsheet_id }}\", \"range\": \"Sheet1!A:C\", \"valueInputOption\": \"USER_ENTERED\", \"values\": [{% for product in scraper_results %}[\"{{ product.name }}\", {{ product.price }}, \"{{ product.url }}\"]{% unless forloop.last %}, {% endunless %}{% endfor %}] }",
      "rendered_config": "{ \"spreadsheetId\": \"1BxiMVs0XRA5nFMdKvBdBZjgmUUqptlbs74OgvE2upms\", \"range\": \"Sheet1!A:C\", \"valueInputOption\": \"USER_ENTERED\", \"values\": [[\"Wireless Headphones\", 79.99, \"https://store.example.com/p/1001\"], [\"USB-C Hub\", 45.0, \"https://store.example.com/p/1002\"]] }",
      "latency_ms": 25158.34212489426,
      "error": null
    },
    {
      "scenario_id": 4,
      "request": "Update the Notion block with the new status message",
      "expected_action": "notion_update_block",
      "actual_action": "notion_update_block",
      "action_correct": true,
      "liquid_valid": true,
      "renders_to_json": true,
      "reasoning": "The user wants to update the content of an existing Notion block, and we have the block_id and the new content. The 'notion_update_block' action is explicitly designed to update a block's content by ID. The config uses the provided block_id and sets the paragraph rich_text to the new_content string, which aligns with Notion's block update structure for text-based blocks.",
      "proposed_config": "{ \"block_id\": \"{{ block_id }}\", \"paragraph\": { \"rich_text\": [ { \"type\": \"text\", \"text\": { \"content\": \"{{ new_content }}\" } } ] } }",
      "rendered_config": "{ \"block_id\": \"b1c2d3e4-5f6a-7b8c-9d0e-1f2a3b4c5d6e\", \"paragraph\": { \"rich_text\": [ { \"type\": \"text\", \"text\": { \"content\": \"Status: Completed \u2705 - All tasks finished successfully.\" } } ] } }",
      "latency_ms": 64674.63837494142,
      "error": null
    },
    {
      "scenario_id": 5,
      "request": "Create a record in my Airtable base with the product data",
      "expected_action": "airtable_create_record",
      "actual_action": "airtable_create_record",
      "action_correct": true,
      "liquid_valid": true,
      "renders_to_json": true,
      "reasoning": "The user wants to create a new record in Airtable using the provided product data. The 'airtable_create_record' action is explicitly designed for creating records. Based on the Airtable API docs, the payload must include a 'records' array with 'fields' mapping to table columns. We use the workflow variables for path parameters (baseId and tableIdOrName) and map product_data fields to Airtable field names, preserving number and boolean types.",
      "proposed_config": "{ \"baseId\": \"{{ base_id }}\", \"tableIdOrName\": \"{{ table_name }}\", \"records\": [ { \"fields\": { \"Name\": \"{{ product_data.name }}\", \"Price\": {{ product_data.price }}, \"Category\": \"{{ product_data.category }}\", \"In Stock\": {{ product_data.in_stock }} } } ] }",
      "rendered_config": "{ \"baseId\": \"appXYZ123456789\", \"tableIdOrName\": \"Products\", \"records\": [ { \"fields\": { \"Name\": \"New Product\", \"Price\": 99.99, \"Category\": \"Electronics\", \"In Stock\": true } } ] }",
      "latency_ms": 36713.89520796947,
      "error": null
    },
    {
      "scenario_id": 6,
      "request": "Add this lead as a contact in HubSpot",
      "expected_action": "hubspot_create_contact",
      "actual_action": "hubspot_create_contact",
      "action_correct": true,
      "liquid_valid": true,
      "renders_to_json": true,
      "reasoning": "The user wants to add a lead as a HubSpot contact. The 'hubspot_create_contact' action is explicitly designed to create contacts in HubSpot. Using the API docs, the payload must include a 'properties' object with standard fields. I mapped the provided lead variables to HubSpot contact properties (email, firstname, lastname, phone, company, jobtitle) and set lifecyclestage to 'lead' to reflect the request.",
      "proposed_config": "{ \"properties\": { \"email\": \"{{ lead.email }}\", \"firstname\": \"{{ lead.first_name }}\", \"lastname\": \"{{ lead.last_name }}\", \"phone\": \"{{ lead.phone }}\", \"company\": \"{{ lead.company }}\", \"jobtitle\": \"{{ lead.job_title }}\", \"lifecyclestage\": \"lead\" } }",
      "rendered_config": "{ \"properties\": { \"email\": \"john.smith@acmecorp.com\", \"firstname\": \"John\", \"lastname\": \"Smith\", \"phone\": \"+1-555-123-4567\", \"company\": \"Acme Corporation\", \"jobtitle\": \"VP of Engineering\", \"lifecyclestage\": \"lead\" } }",
      "latency_ms": 25654.593125218526,
      "error": null
    },
    {
      "scenario_id": 7,
      "request": "Create a Trello card for this task",
      "expected_action": "trello_create_card",
      "actual_action": "trello_create_card",
      "action_correct": true,
      "liquid_valid": true,
      "renders_to_json": true,
      "reasoning": "The user asked to create a Trello card. The available actions show 'trello_create_card' as the appropriate action. According to the Trello Create Card API docs, idList is required and we can also set name, desc, and due. We map list_id to idList, task.name to name, task.description to desc, and task.due_date to due. The Liquid template will render to valid JSON with the provided workflow variables.",
      "proposed_config": "{ \"idList\": \"{{ list_id }}\", \"name\": \"{{ task.name }}\", \"desc\": \"{{ task.description }}\", \"due\": \"{{ task.due_date }}\" }",
      "rendered_config": "{ \"idList\": \"5f1a2b3c4d5e6f7a8b9c0d1e\", \"name\": \"Review pull request #42\", \"desc\": \"Code review needed for the authentication module updates\", \"due\": \"2024-01-15T17:00:00Z\" }",
      "latency_ms": 22867.307583102956,
      "error": null
    },
    {
      "scenario_id": 8,
      "request": "Create a Jira ticket for this bug",
      "expected_action": "jira_create_issue",
      "actual_action": "jira_create_issue",
      "action_correct": true,
      "liquid_valid": true,
      "renders_to_json": true,
      "reasoning": "The user asked to create a Jira ticket. The 'jira_create_issue' action is specifically for creating new issues in Jira. Using the provided variables, we map project_key to fields.project.key, bug.summary to fields.summary, set issuetype to 'Bug', include labels via a loop, and set priority from bug.priority. For description, Jira Cloud v3 expects ADF, so we wrap bug.description in a minimal ADF document.",
      "proposed_config": "{ \"fields\": { \"project\": { \"key\": \"{{ project_key }}\" }, \"summary\": \"{{ bug.summary }}\", \"issuetype\": { \"name\": \"Bug\" }, \"description\": { \"type\": \"doc\", \"version\": 1, \"content\": [ { \"type\": \"paragraph\", \"content\": [ { \"type\": \"text\", \"text\": \"{{ bug.description }}\" } ] } ] }, \"priority\": { \"name\": \"{{ bug.priority }}\" }, \"labels\": [ {% for label in labels %}\"{{ label }}\"{% unless forloop.last %}, {% endunless %}{% endfor %} ] } }",
      "rendered_config": "{ \"fields\": { \"project\": { \"key\": \"PROJ\" }, \"summary\": \"Login page returns 500 error on mobile\", \"issuetype\": { \"name\": \"Bug\" }, \"description\": { \"type\": \"doc\", \"version\": 1, \"content\": [ { \"type\": \"paragraph\", \"content\": [ { \"type\": \"text\", \"text\": \"Users on iOS Safari cannot log in. Error occurs after entering credentials.\" } ] } ] }, \"priority\": { \"name\": \"High\" }, \"labels\": [ \"mobile\", \"urgent\", \"login\" ] } }",
      "latency_ms": 27582.10249990225,
      "error": null
    },
    {
      "scenario_id": 9,
      "request": "Create a new customer in Stripe for this signup",
      "expected_action": "stripe_create_customer",
      "actual_action": "stripe_create_customer",
      "action_correct": true,
      "liquid_valid": true,
      "renders_to_json": true,
      "reasoning": "The user wants to create a new customer in Stripe. The 'stripe_create_customer' action directly matches this intent. Using the available workflow variables, we map customer.email, customer.name, and customer.phone to Stripe's customer fields and include plan and signup_source in metadata for reporting/segmentation. The payload structure follows the Stripe Create Customer API documentation.",
      "proposed_config": "{ \"email\": \"{{ customer.email }}\", \"name\": \"{{ customer.name }}\", \"phone\": \"{{ customer.phone }}\", \"description\": \"Signup from {{ signup_source }} - Plan: {{ plan }}\", \"metadata\": { \"plan\": \"{{ plan }}\", \"signup_source\": \"{{ signup_source }}\" } }",
      "rendered_config": "{ \"email\": \"newuser@example.com\", \"name\": \"Jane Doe\", \"phone\": \"+1-555-987-6543\", \"description\": \"Signup from landing_page - Plan: premium\", \"metadata\": { \"plan\": \"premium\", \"signup_source\": \"landing_page\" } }",
      "latency_ms": 30951.215917011723,
      "error": null
    },
    {
      "scenario_id": 10,
      "request": "Send an email notification via SendGrid about the order",
      "expected_action": "sendgrid_send_email",
      "actual_action": "sendgrid_send_email",
      "action_correct": true,
      "liquid_valid": true,
      "renders_to_json": true,
      "reasoning": "The user wants to send an email via SendGrid. The 'sendgrid_send_email' action directly matches this need. Using the provided variables (recipient, order, from_email, from_name), we construct a valid SendGrid v3 Mail Send payload including required fields: personalizations, from, subject, and content. We include both text/plain and text/html content per the API documentation.",
      "proposed_config": "{ \"personalizations\": [ { \"to\": [ { \"email\": \"{{ recipient.email }}\", \"name\": \"{{ recipient.name }}\" } ] } ], \"from\": { \"email\": \"{{ from_email }}\", \"name\": \"{{ from_name }}\" }, \"subject\": \"Your order {{ order.id }} is {{ order.status }}\", \"content\": [ { \"type\": \"text/plain\", \"value\": \"Hi {{ recipient.name }},\\n\\nYour order {{ order.id }} is now {{ order.status }}.\\nTotal: {{ order.total }}\\n\\nThank you,\\n{{ from_name }}\" }, { \"type\": \"text/html\", \"value\": \"<html><body><p>Hi {{ recipient.name }},</p><p>Your order <strong>{{ order.id }}</strong> is now <strong>{{ order.status }}</strong>.</p><p>Total: <strong>{{ order.total }}</strong></p><p>Thank you,<br>{{ from_name }}</p></body></html>\" } ] }",
      "rendered_config": "{ \"personalizations\": [ { \"to\": [ { \"email\": \"customer@example.com\", \"name\": \"John Customer\" } ] } ], \"from\": { \"email\": \"orders@store.com\", \"name\": \"Store Notifications\" }, \"subject\": \"Your order ORD-12345 is shipped\", \"content\": [ { \"type\": \"text/plain\", \"value\": \"Hi John Customer,\\n\\nYour order ORD-12345 is now shipped.\\nTotal: $149.99\\n\\nThank you,\\nStore Notifications\" }, { \"type\": \"text/html\", \"value\": \"<html><body><p>Hi John Customer,</p><p>Your order <strong>ORD-12345</strong> is now <strong>shipped</strong>.</p><p>Total: <strong>$149.99</strong></p><p>Thank you,<br>Store Notifications</p></body></html>\" } ] }",
      "latency_ms": 25841.297292150557,
      "error": null
    },
    {
      "scenario_id": 11,
      "request": "Send an SMS alert via Twilio about the system status",
      "expected_action": "twilio_send_sms",
      "actual_action": "twilio_send_sms",
      "action_correct": true,
      "liquid_valid": true,
      "renders_to_json": true,
      "reasoning": "The user wants to send an SMS alert. The 'twilio_send_sms' action is the correct choice for sending text messages. Based on the API docs, the required fields are To, From, and Body. We map To to alert_phone, From to twilio_number, and construct Body using the alert object fields (message, type, timestamp) provided in the workflow variables.",
      "proposed_config": "{ \"To\": \"{{ alert_phone }}\", \"From\": \"{{ twilio_number }}\", \"Body\": \"System Status Alert: {{ alert.message }}\\nType: {{ alert.type }}\\nTime: {{ alert.timestamp }}\" }",
      "rendered_config": "{ \"To\": \"+14155551234\", \"From\": \"+14155559876\", \"Body\": \"System Status Alert: CPU usage exceeded 90% on production server\\nType: warning\\nTime: 2024-01-08T14:30:00Z\" }",
      "latency_ms": 26379.704957827926,
      "error": null
    }
  ]
}